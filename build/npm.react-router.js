"use strict";(self.__LOADABLE_LOADED_CHUNKS__=self.__LOADABLE_LOADED_CHUNKS__||[]).push([["npm.react-router"],{"./node_modules/react-router/index.js":(e,t,n)=>{n.r(t),n.d(t,{MemoryRouter:()=>c,Navigate:()=>p,NavigationType:()=>r.Action,Outlet:()=>m,Route:()=>d,Router:()=>f,Routes:()=>g,UNSAFE_LocationContext:()=>u,UNSAFE_NavigationContext:()=>l,UNSAFE_RouteContext:()=>h,createPath:()=>r.createPath,createRoutesFromChildren:()=>A,generatePath:()=>L,matchPath:()=>I,matchRoutes:()=>$,parsePath:()=>r.parsePath,renderMatches:()=>U,resolvePath:()=>F,useHref:()=>v,useInRouterContext:()=>y,useLocation:()=>R,useMatch:()=>b,useNavigate:()=>P,useNavigationType:()=>x,useOutlet:()=>E,useOutletContext:()=>C,useParams:()=>N,useResolvedPath:()=>S,useRoutes:()=>_});var a=n("./node_modules/react/index.js"),r=n("./node_modules/history/index.js");function o(e,t){if(!e)throw new Error(t)}function s(e,t){if(!e){"undefined"!=typeof console&&console.warn(t);try{throw new Error(t)}catch(e){}}}const i={};const l=(0,a.createContext)(null);l.displayName="Navigation";const u=(0,a.createContext)(null);u.displayName="Location";const h=(0,a.createContext)({outlet:null,matches:[]});function c(e){let{basename:t,children:n,initialEntries:o,initialIndex:s}=e,i=(0,a.useRef)();null==i.current&&(i.current=(0,r.createMemoryHistory)({initialEntries:o,initialIndex:s}));let l=i.current,[u,h]=(0,a.useState)({action:l.action,location:l.location});return(0,a.useLayoutEffect)((()=>l.listen(h)),[l]),(0,a.createElement)(f,{basename:t,children:n,location:u.location,navigationType:u.action,navigator:l})}function p(e){let{to:t,replace:n,state:r}=e;y()||o(!1,"<Navigate> may be used only in the context of a <Router> component."),s(!(0,a.useContext)(l).static,"<Navigate> must not be used on the initial render in a <StaticRouter>. This is a no-op, but you should modify your code so the <Navigate> is only ever rendered in response to some user interaction or state change.");let i=P();return(0,a.useEffect)((()=>{i(t,{replace:n,state:r})})),null}function m(e){return E(e.context)}function d(e){o(!1,"A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>.")}function f(e){let{basename:t="/",children:n=null,location:i,navigationType:h=r.Action.Pop,navigator:c,static:p=!1}=e;y()&&o(!1,"You cannot render a <Router> inside another <Router>. You should never have more than one in your app.");let m=Y(t),d=(0,a.useMemo)((()=>({basename:m,navigator:c,static:p})),[m,c,p]);"string"==typeof i&&(i=(0,r.parsePath)(i));let{pathname:f="/",search:g="",hash:v="",state:R=null,key:x="default"}=i,b=(0,a.useMemo)((()=>{let e=H(f,m);return null==e?null:{pathname:e,search:g,hash:v,state:R,key:x}}),[m,f,g,v,R,x]);return s(null!=b,'<Router basename="'+m+'"> is not able to match the URL "'+f+g+v+"\" because it does not start with the basename, so the <Router> won't render anything."),null==b?null:(0,a.createElement)(l.Provider,{value:d},(0,a.createElement)(u.Provider,{children:n,value:{location:b,navigationType:h}}))}function g(e){let{children:t,location:n}=e;return _(A(t),n)}function v(e){y()||o(!1,"useHref() may be used only in the context of a <Router> component.");let{basename:t,navigator:n}=(0,a.useContext)(l),{hash:s,pathname:i,search:u}=S(e),h=i;if("/"!==t){let n=function(e){return""===e||""===e.pathname?"/":"string"==typeof e?(0,r.parsePath)(e).pathname:e.pathname}(e),a=null!=n&&n.endsWith("/");h="/"===i?t+(a?"/":""):J([t,i])}return n.createHref({pathname:h,search:u,hash:s})}function y(){return null!=(0,a.useContext)(u)}function R(){return y()||o(!1,"useLocation() may be used only in the context of a <Router> component."),(0,a.useContext)(u).location}function x(){return(0,a.useContext)(u).navigationType}function b(e){y()||o(!1,"useMatch() may be used only in the context of a <Router> component.");let{pathname:t}=R();return(0,a.useMemo)((()=>I(e,t)),[t,e])}function P(){y()||o(!1,"useNavigate() may be used only in the context of a <Router> component.");let{basename:e,navigator:t}=(0,a.useContext)(l),{matches:n}=(0,a.useContext)(h),{pathname:r}=R(),i=JSON.stringify(n.map((e=>e.pathnameBase))),u=(0,a.useRef)(!1);return(0,a.useEffect)((()=>{u.current=!0})),(0,a.useCallback)((function(n,a){if(void 0===a&&(a={}),s(u.current,"You should call navigate() in a React.useEffect(), not when your component is first rendered."),!u.current)return;if("number"==typeof n)return void t.go(n);let o=D(n,JSON.parse(i),r);"/"!==e&&(o.pathname=J([e,o.pathname])),(a.replace?t.replace:t.push)(o,a.state)}),[e,t,i,r])}h.displayName="Route";const w=(0,a.createContext)(null);function C(){return(0,a.useContext)(w)}function E(e){let t=(0,a.useContext)(h).outlet;return t?(0,a.createElement)(w.Provider,{value:e},t):t}function N(){let{matches:e}=(0,a.useContext)(h),t=e[e.length-1];return t?t.params:{}}function S(e){let{matches:t}=(0,a.useContext)(h),{pathname:n}=R(),r=JSON.stringify(t.map((e=>e.pathnameBase)));return(0,a.useMemo)((()=>D(e,JSON.parse(r),n)),[e,r,n])}function _(e,t){y()||o(!1,"useRoutes() may be used only in the context of a <Router> component.");let{matches:n}=(0,a.useContext)(h),l=n[n.length-1],u=l?l.params:{},c=l?l.pathname:"/",p=l?l.pathnameBase:"/",m=l&&l.route;{let e=m&&m.path||"";d=c,f=!m||e.endsWith("*"),g='You rendered descendant <Routes> (or called `useRoutes()`) at "'+c+'" (under <Route path="'+e+'">) but the parent route path has no trailing "*". This means if you navigate deeper, the parent won\'t match anymore and therefore the child routes will never render.\n\nPlease change the parent <Route path="'+e+'"> to <Route path="'+("/"===e?"*":e+"/*")+'">.',f||i[d]||(i[d]=!0,s(!1,g))}var d,f,g;let v,x=R();if(t){var b;let e="string"==typeof t?(0,r.parsePath)(t):t;"/"===p||(null==(b=e.pathname)?void 0:b.startsWith(p))||o(!1,'When overriding the location using `<Routes location>` or `useRoutes(routes, location)`, the location pathname must begin with the portion of the URL pathname that was matched by all parent routes. The current pathname base is "'+p+'" but pathname "'+e.pathname+'" was given in the `location` prop.'),v=e}else v=x;let P=v.pathname||"/",w=$(e,{pathname:"/"===p?P:P.slice(p.length)||"/"});return s(m||null!=w,'No routes matched location "'+v.pathname+v.search+v.hash+'" '),s(null==w||void 0!==w[w.length-1].route.element,'Matched leaf route at location "'+v.pathname+v.search+v.hash+'" does not have an element. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.'),j(w&&w.map((e=>Object.assign({},e,{params:Object.assign({},u,e.params),pathname:J([p,e.pathname]),pathnameBase:"/"===e.pathnameBase?p:J([p,e.pathnameBase])}))),n)}function A(e){let t=[];return a.Children.forEach(e,(e=>{if(!(0,a.isValidElement)(e))return;if(e.type===a.Fragment)return void t.push.apply(t,A(e.props.children));e.type!==d&&o(!1,"["+("string"==typeof e.type?e.type:e.type.name)+"] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>");let n={caseSensitive:e.props.caseSensitive,element:e.props.element,index:e.props.index,path:e.props.path};e.props.children&&(n.children=A(e.props.children)),t.push(n)})),t}function L(e,t){return void 0===t&&(t={}),e.replace(/:(\w+)/g,((e,n)=>(null==t[n]&&o(!1,'Missing ":'+n+'" param'),t[n]))).replace(/\/*\*$/,(e=>null==t["*"]?"":t["*"].replace(/^\/*/,"/")))}function $(e,t,n){void 0===n&&(n="/");let a=H(("string"==typeof t?(0,r.parsePath)(t):t).pathname||"/",n);if(null==a)return null;let o=W(e);!function(e){e.sort(((e,t)=>e.score!==t.score?t.score-e.score:function(e,t){return e.length===t.length&&e.slice(0,-1).every(((e,n)=>e===t[n]))?e[e.length-1]-t[t.length-1]:0}(e.routesMeta.map((e=>e.childrenIndex)),t.routesMeta.map((e=>e.childrenIndex)))))}(o);let s=null;for(let e=0;null==s&&e<o.length;++e)s=T(o[e],a);return s}function W(e,t,n,a){return void 0===t&&(t=[]),void 0===n&&(n=[]),void 0===a&&(a=""),e.forEach(((e,r)=>{let s={relativePath:e.path||"",caseSensitive:!0===e.caseSensitive,childrenIndex:r,route:e};s.relativePath.startsWith("/")&&(s.relativePath.startsWith(a)||o(!1,'Absolute route path "'+s.relativePath+'" nested under path "'+a+'" is not valid. An absolute child route path must start with the combined path of all its parent routes.'),s.relativePath=s.relativePath.slice(a.length));let i=J([a,s.relativePath]),l=n.concat(s);e.children&&e.children.length>0&&(!0===e.index&&o(!1,'Index routes must not have child routes. Please remove all child routes from route path "'+i+'".'),W(e.children,t,l,i)),(null!=e.path||e.index)&&t.push({path:i,score:B(i,e.index),routesMeta:l})})),t}const M=/^:\w+$/,O=e=>"*"===e;function B(e,t){let n=e.split("/"),a=n.length;return n.some(O)&&(a+=-2),t&&(a+=2),n.filter((e=>!O(e))).reduce(((e,t)=>e+(M.test(t)?3:""===t?1:10)),a)}function T(e,t){let{routesMeta:n}=e,a={},r="/",o=[];for(let e=0;e<n.length;++e){let s=n[e],i=e===n.length-1,l="/"===r?t:t.slice(r.length)||"/",u=I({path:s.relativePath,caseSensitive:s.caseSensitive,end:i},l);if(!u)return null;Object.assign(a,u.params);let h=s.route;o.push({params:a,pathname:J([r,u.pathname]),pathnameBase:Y(J([r,u.pathnameBase])),route:h}),"/"!==u.pathnameBase&&(r=J([r,u.pathnameBase]))}return o}function U(e){return j(e)}function j(e,t){return void 0===t&&(t=[]),null==e?null:e.reduceRight(((n,r,o)=>(0,a.createElement)(h.Provider,{children:void 0!==r.route.element?r.route.element:n,value:{outlet:n,matches:t.concat(e.slice(0,o+1))}})),null)}function I(e,t){"string"==typeof e&&(e={path:e,caseSensitive:!1,end:!0});let[n,a]=function(e,t,n){void 0===t&&(t=!1);void 0===n&&(n=!0);s("*"===e||!e.endsWith("*")||e.endsWith("/*"),'Route path "'+e+'" will be treated as if it were "'+e.replace(/\*$/,"/*")+'" because the `*` character must always follow a `/` in the pattern. To get rid of this warning, please change the route path to "'+e.replace(/\*$/,"/*")+'".');let a=[],r="^"+e.replace(/\/*\*?$/,"").replace(/^\/*/,"/").replace(/[\\.*+^$?{}|()[\]]/g,"\\$&").replace(/:(\w+)/g,((e,t)=>(a.push(t),"([^\\/]+)")));e.endsWith("*")?(a.push("*"),r+="*"===e||"/*"===e?"(.*)$":"(?:\\/(.+)|\\/*)$"):r+=n?"\\/*$":"(?:(?=[.~-]|%[0-9A-F]{2})|\\b|\\/|$)";return[new RegExp(r,t?void 0:"i"),a]}(e.path,e.caseSensitive,e.end),r=t.match(n);if(!r)return null;let o=r[0],i=o.replace(/(.)\/+$/,"$1"),l=r.slice(1);return{params:a.reduce(((e,t,n)=>{if("*"===t){let e=l[n]||"";i=o.slice(0,o.length-e.length).replace(/(.)\/+$/,"$1")}return e[t]=function(e,t){try{return decodeURIComponent(e)}catch(n){return s(!1,'The value for the URL param "'+t+'" will not be decoded because the string "'+e+'" is a malformed URL segment. This is probably due to a bad percent encoding ('+n+")."),e}}(l[n]||"",t),e}),{}),pathname:o,pathnameBase:i,pattern:e}}function F(e,t){void 0===t&&(t="/");let{pathname:n,search:a="",hash:o=""}="string"==typeof e?(0,r.parsePath)(e):e,s=n?n.startsWith("/")?n:function(e,t){let n=t.replace(/\/+$/,"").split("/");return e.split("/").forEach((e=>{".."===e?n.length>1&&n.pop():"."!==e&&n.push(e)})),n.length>1?n.join("/"):"/"}(n,t):t;return{pathname:s,search:k(a),hash:K(o)}}function D(e,t,n){let a,o="string"==typeof e?(0,r.parsePath)(e):e,s=""===e||""===o.pathname?"/":o.pathname;if(null==s)a=n;else{let e=t.length-1;if(s.startsWith("..")){let t=s.split("/");for(;".."===t[0];)t.shift(),e-=1;o.pathname=t.join("/")}a=e>=0?t[e]:"/"}let i=F(o,a);return s&&"/"!==s&&s.endsWith("/")&&!i.pathname.endsWith("/")&&(i.pathname+="/"),i}function H(e,t){if("/"===t)return e;if(!e.toLowerCase().startsWith(t.toLowerCase()))return null;let n=e.charAt(t.length);return n&&"/"!==n?null:e.slice(t.length)||"/"}const J=e=>e.join("/").replace(/\/\/+/g,"/"),Y=e=>e.replace(/\/+$/,"").replace(/^\/*/,"/"),k=e=>e&&"?"!==e?e.startsWith("?")?e:"?"+e:"",K=e=>e&&"#"!==e?e.startsWith("#")?e:"#"+e:""}}]);
//# sourceMappingURL=npm.react-router.js.map